#include "../board.h"
#include "../logic.h"
#include "../network_protocol.h"
#include "../piece.h"
#include "gtest/gtest.h"

// ... (existing code)

TEST(LogicSyncTest, DirtyStateCheck) {
  Logic p1;
  Logic p2;

  // Make p1 very dirty - consume random amount of numbers
  p1.Reset();
  for (int i = 0; i < 13; i++) {
    p1.SpawnPiece(); // Consumes RNG
  }

  // p2 is fresh or used differently
  p2.Reset();
  p2.SpawnPiece();

  // Now Sync
  int seed = 8888;
  p1.Reset(seed);
  p2.Reset(seed);

  EXPECT_EQ(p1.currentPiece.type, p2.currentPiece.type)
      << "Current piece mismatch after dirty state";
  EXPECT_EQ(p1.nextPiece.type, p2.nextPiece.type)
      << "Next piece mismatch after dirty state";
}

TEST(NetworkProtocolTest, Parsing) {
  // 1. Test GAME_START
  std::string startMsg =
      NetworkProtocol::SerializeGameStart(12345, "PlayerOne");
  NetworkMessage parsedStart = NetworkProtocol::Parse(startMsg);
  EXPECT_EQ(parsedStart.type, NetworkMsgType::GAME_START);
  EXPECT_EQ(parsedStart.intParam1, 12345);

  // 2. Test MOVE_LR
  std::string moveMsg = NetworkProtocol::SerializeMoveLR(-1);
  NetworkMessage parsedMove = NetworkProtocol::Parse(moveMsg);
  EXPECT_EQ(parsedMove.type, NetworkMsgType::MOVE_LR);
  EXPECT_EQ(parsedMove.intParam1, -1);
}

// Helper fixture for tests that need a specific initial state
class LogicTest : public ::testing::Test {
protected:
  Logic logic;

  void SetUp() override {
    // Reset the board for a clean slate for each test using this fixture.
    logic.board.Reset();
    // Manually set currentPiece to a known state for existing tests.
    // This overrides the random piece generated by the Logic constructor.
    logic.currentPiece = Piece(PieceType::I);
    logic.currentPiece.x = BOARD_WIDTH / 2 - 2;
    logic.currentPiece.y = 0;
    logic.currentPiece.rotation = 0;
    // nextPiece is not directly tested by existing fixture tests, so no need to
    // set it.
  }

  // Helper to fill a row on the board
  void FillRow(int row_idx) {
    for (int c = 0; c < BOARD_WIDTH; ++c)
      logic.board.SetCell(row_idx, c, 1);
  }

  // Helper to check if a row is empty
  bool IsRowEmpty(int row_idx) {
    for (int c = 0; c < BOARD_WIDTH; ++c) {
      if (logic.board.GetCell(row_idx, c) != 0)
        return false;
    }
    return true;
  }
};

TEST_F(LogicTest, MoveLeft) {
  int initialX = logic.currentPiece.x;
  logic.Move(-1, 0);
  ASSERT_EQ(logic.currentPiece.x, initialX - 1);
}

TEST_F(LogicTest, MoveRight) {
  int initialX = logic.currentPiece.x;
  logic.Move(1, 0);
  ASSERT_EQ(logic.currentPiece.x, initialX + 1);
}

TEST_F(LogicTest, Rotate) {
  logic.Rotate();
  ASSERT_EQ(logic.currentPiece.rotation, 1);
  logic.Rotate();
  ASSERT_EQ(logic.currentPiece.rotation, 2);
}

TEST_F(LogicTest, LineClear) {
  // Fill the bottom row to simulate a full line
  FillRow(BOARD_HEIGHT - 1);

  // Call CheckLines() directly to test its logic
  logic.CheckLines();

  // The bottom row should now be empty after clearing
  ASSERT_TRUE(IsRowEmpty(BOARD_HEIGHT - 1));
}

TEST_F(LogicTest, CollisionTest) {
  logic.currentPiece.x = 0;           // Move piece to the far left
  logic.Move(-1, 0);                  // Attempt to move further left
  ASSERT_EQ(logic.currentPiece.x, 0); // Should not move past the wall
}

// New test for the Next Piece Preview feature
TEST(LogicNextPieceTest, NextPieceSpawn) {
  // Create a fresh Logic instance to test its constructor and SpawnPiece
  // behavior
  Logic logic;

  // 1. Check that nextPiece is initialized and not NONE.
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.nextPiece.type),
            1); // Ensure it's a valid piece type (1-7)
  ASSERT_LE(static_cast<int>(logic.nextPiece.type), 7);

  // 2. Store the type of the initial nextPiece.
  PieceType initialNextPieceType = logic.nextPiece.type;

  // Also check that currentPiece is initialized and not NONE.
  ASSERT_NE(logic.currentPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.currentPiece.type), 1);
  ASSERT_LE(static_cast<int>(logic.currentPiece.type), 7);

  // To trigger SpawnPiece (which happens after LockPiece),
  // we need to move currentPiece to a position where it will lock.
  // Create a temporary piece to find the lock position without modifying
  // logic.currentPiece prematurely.
  Piece pieceToMove = logic.currentPiece;
  // Ensure all relevant properties are copied for the simulation
  pieceToMove.x = logic.currentPiece.x;
  pieceToMove.y = logic.currentPiece.y;
  pieceToMove.rotation = logic.currentPiece.rotation;

  // Move the piece down until it hits the bottom or another block
  while (logic.IsValidPosition(pieceToMove)) {
    pieceToMove.y++;
  }
  // Move it back up one step, so it's in a valid position but will lock on the
  // next downward movement or LockPiece call.
  pieceToMove.y--;

  // Set the logic's currentPiece to this calculated lock position.
  logic.currentPiece = pieceToMove;

  // Now, call LockPiece. This will lock the currentPiece and then call
  // SpawnPiece internally.
  logic.LockPiece();
  logic.SpawnPiece(); // Fix: LockPiece no longer calls SpawnPiece
                      // automatically, manual call required for test

  // 4. Assert that the new currentPiece's type is equal to the type of the OLD
  // nextPiece.
  ASSERT_EQ(logic.currentPiece.type, initialNextPieceType);

  // 5. Assert that nextPiece has changed (i.e., it's a new valid random piece).
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.nextPiece.type),
            1); // Ensure it's a valid piece type
  ASSERT_LE(static_cast<int>(logic.nextPiece.type), 7);

  // Assert that the new nextPiece is valid
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  // Note: It IS possible for nextPiece to be same type as currentPiece (random
  // 1/7 chance), so we don't assert inequality here.
}

TEST_F(LogicTest, GameOverOnSpawnCollision) {
  // Fill the spawn area (top center) with blocks
  // Spawn usually happens at (BOARD_WIDTH/2 - 2, 0) => (3, 0) roughly
  // Let's fill row 0 and 1 completely to guarantee collision
  for (int x = 0; x < 10; x++) {
    logic.board.SetCell(0, x, 1);
    logic.board.SetCell(1, x, 1);
  }

  // Attempt to spawn a new piece
  logic.SpawnPiece();

  // Should trigger Game Over because the new piece collides immediately
  EXPECT_TRUE(logic.isGameOver);
}

TEST_F(LogicTest, ResetClearsGameState) {
  // 1. Set up a "dirty" state
  logic.isGameOver = true;
  logic.score = 5000;           // Simulate some score
  logic.board.SetCell(5, 5, 1); // Set a random block

  // 2. Call Reset
  logic.Reset();

  // 3. Assert clean state
  EXPECT_FALSE(logic.isGameOver);
  EXPECT_EQ(logic.score, 0); // Score should be reset to 0

  // Board should be empty
  EXPECT_EQ(logic.board.GetCell(5, 5), 0);

  // Should have a valid current piece spawned
  EXPECT_NE(logic.currentPiece.type, PieceType::NONE);
}

TEST_F(LogicTest, ScoreCalculation) {
  // 1. Single Line Clear (100)
  logic.score = 0;
  FillRow(BOARD_HEIGHT - 1);
  logic.CheckLines();
  EXPECT_EQ(logic.score, 100);

  // 2. Double Line Clear (300) -> Total 400
  logic.score = 0; // Reset for clarity
  FillRow(BOARD_HEIGHT - 1);
  FillRow(BOARD_HEIGHT - 2);
  logic.CheckLines();
  EXPECT_EQ(logic.score, 300);

  // 3. Triple Line Clear (500)
  logic.score = 0;
  FillRow(BOARD_HEIGHT - 1);
  FillRow(BOARD_HEIGHT - 2);
  FillRow(BOARD_HEIGHT - 3);
  logic.CheckLines();
  EXPECT_EQ(logic.score, 500);

  // 4. Tetris (4 Lines) (800)
  logic.score = 0;
  FillRow(BOARD_HEIGHT - 1);
  FillRow(BOARD_HEIGHT - 2);
  FillRow(BOARD_HEIGHT - 3);
  FillRow(BOARD_HEIGHT - 4);
  logic.CheckLines();
  EXPECT_EQ(logic.score, 800);
}

TEST_F(LogicTest, MoveLeftBoundary) {
  // Find left-most valid x
  while (true) {
    Piece test = logic.currentPiece;
    test.x--;
    if (!logic.IsValidPosition(test))
      break;
    logic.currentPiece.x--;
  }

  int minX = logic.currentPiece.x;

  // Try to move left again (hit wall)
  logic.Move(-1, 0);

  // Should stay at minX
  EXPECT_EQ(logic.currentPiece.x, minX);
}

TEST_F(LogicTest, MoveRightBoundary) {
  // Move to right-most valid position
  while (true) {
    Piece test = logic.currentPiece;
    test.x++;
    if (!logic.IsValidPosition(test))
      break;
    logic.currentPiece.x++;
  }

  int maxX = logic.currentPiece.x;

  // Try to move right again (hit wall)
  logic.Move(1, 0);

  // Should stay at maxX
  EXPECT_EQ(logic.currentPiece.x, maxX);
}

TEST_F(LogicTest, MoveCollision) {
  // Test Collision Logic
  // Place piece at specific location (5,5)
  logic.currentPiece.x = 5;
  logic.currentPiece.y = 5;

  // Ensure assumed start position is valid
  if (!logic.IsValidPosition(logic.currentPiece)) {
    // Fallback: clear board area just in case
    for (int r = 0; r < 10; r++)
      for (int c = 0; c < 10; c++)
        logic.board.SetCell(r, c, 0);
  }
  ASSERT_TRUE(logic.IsValidPosition(logic.currentPiece));

  // Build a WALL at x=4 (Left of piece)
  for (int r = 0; r < 20; r++)
    logic.board.SetCell(r, 4, 1);

  // Try to move LEFT (from 5 to 4) -> Should Fail due to Wall
  int startX = logic.currentPiece.x;
  logic.Move(-1, 0);

  EXPECT_EQ(logic.currentPiece.x, startX);
}

TEST_F(LogicTest, LineClearGravity) {
  // Setup:
  // Row 19 (Bottom): Full -> Should be cleared
  // Row 18 (Above):  Has one block at x=5 -> Should drop to Row 19
  FillRow(BOARD_HEIGHT - 1);
  logic.board.SetCell(BOARD_HEIGHT - 2, 5, 1);

  // Action
  logic.CheckLines();

  // Assert:
  // Row 19 should now contain the block that fell from Row 18
  EXPECT_EQ(logic.board.GetCell(BOARD_HEIGHT - 1, 5), 1);
  // Row 18 should be empty now
  EXPECT_EQ(logic.board.GetCell(BOARD_HEIGHT - 2, 5), 0);
}

TEST_F(LogicTest, MultiLineClear) {
  // Setup:
  // Row 18, 19: Full -> Should be cleared
  // Row 17: Block at x=0 -> Should drop to Row 19 (drop 2 lines)
  FillRow(BOARD_HEIGHT - 1);                   // Row 19
  FillRow(BOARD_HEIGHT - 2);                   // Row 18
  logic.board.SetCell(BOARD_HEIGHT - 3, 0, 1); // Row 17

  // Action
  logic.CheckLines();

  // Assert:
  // Rows 18, 17 should be empty (Row 17 fell, Row 18 cleared)
  // Actually, Row 17's block fell to Row 19.
  EXPECT_EQ(logic.board.GetCell(BOARD_HEIGHT - 1, 0), 1); // From Row 17 -> 19
  EXPECT_EQ(logic.board.GetCell(BOARD_HEIGHT - 2, 0),
            0); // Row 18 was cleared, nothing above to fill it
  EXPECT_EQ(logic.board.GetCell(BOARD_HEIGHT - 3, 0), 0); // Row 17 moved down
}
TEST(LogicSyncTest, TwoPlayersSameSeedProduceSamePieces) {
  Logic p1;
  Logic p2;
  int seed = 12345;

  p1.Reset(seed);
  p2.Reset(seed);

  // Check initial pieces
  EXPECT_EQ(p1.currentPiece.type, p2.currentPiece.type);
  EXPECT_EQ(p1.nextPiece.type, p2.nextPiece.type);

  // Check 50 random spawns
  for (int i = 0; i < 50; i++) {
    p1.SpawnPiece();
    p2.SpawnPiece();
    EXPECT_EQ(p1.currentPiece.type, p2.currentPiece.type)
        << "Mismatch at spawn " << i;
    EXPECT_EQ(p1.nextPiece.type, p2.nextPiece.type)
        << "Mismatch next at spawn " << i;
  }
}

TEST_F(LogicTest, TickLocking) {
  // 1. Move piece to the bottom-most valid position
  while (true) {
    Piece next = logic.currentPiece;
    next.y++;
    if (!logic.IsValidPosition(next))
      break;
    logic.currentPiece.y++;
  }

  // Record state before Tick
  int preTicketSpawnCounter = logic.spawnCounter;
  int bottomY = logic.currentPiece.y;
  int pieceX = logic.currentPiece.x;

  // 2. Call Tick. Since we are at the bottom, this should Trigger Lock -> Spawn
  logic.Tick();

  // 3. Verify
  // Spawn counter should increment
  EXPECT_GT(logic.spawnCounter, preTicketSpawnCounter);

  // Current piece should be new (spawned at top y=0 usually)
  EXPECT_EQ(logic.currentPiece.y, 0);

  // The board should have blocks where the piece was locked
  // Since SetUp uses I-piece (horizontal usually), check the cell at (bottomY,
  // pieceX) Warning: Exact offset depends on Piece definition. But generally
  // (0,0) of piece is (x,y). Let's iterate the board row at bottomY or check
  // known block. We can check if the board is NOT empty anymore.
  bool boardHasBlocks = false;
  for (int r = 0; r < BOARD_HEIGHT; r++) {
    for (int c = 0; c < BOARD_WIDTH; c++) {
      if (logic.board.GetCell(r, c) != 0) {
        boardHasBlocks = true;
        break;
      }
    }
    if (boardHasBlocks)
      break;
  }
  EXPECT_TRUE(boardHasBlocks)
      << "Board should contain locked piece blocks after Tick";
}
