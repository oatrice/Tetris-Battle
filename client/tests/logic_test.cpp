#include "../board.h"
#include "../logic.h"
#include "../piece.h"
#include "gtest/gtest.h"

// Helper fixture for tests that need a specific initial state
class LogicTest : public ::testing::Test {
protected:
  Logic logic;

  void SetUp() override {
    // Reset the board for a clean slate for each test using this fixture.
    logic.board.Reset();
    // Manually set currentPiece to a known state for existing tests.
    // This overrides the random piece generated by the Logic constructor.
    logic.currentPiece = Piece(PieceType::I);
    logic.currentPiece.x = BOARD_WIDTH / 2 - 2;
    logic.currentPiece.y = 0;
    logic.currentPiece.rotation = 0;
    // nextPiece is not directly tested by existing fixture tests, so no need to
    // set it.
  }

  // Helper to fill a row on the board
  void FillRow(int row_idx) {
    for (int c = 0; c < BOARD_WIDTH; ++c)
      logic.board.SetCell(row_idx, c, 1);
  }

  // Helper to check if a row is empty
  bool IsRowEmpty(int row_idx) {
    for (int c = 0; c < BOARD_WIDTH; ++c) {
      if (logic.board.GetCell(row_idx, c) != 0)
        return false;
    }
    return true;
  }
};

TEST_F(LogicTest, MoveLeft) {
  int initialX = logic.currentPiece.x;
  logic.Move(-1, 0);
  ASSERT_EQ(logic.currentPiece.x, initialX - 1);
}

TEST_F(LogicTest, MoveRight) {
  int initialX = logic.currentPiece.x;
  logic.Move(1, 0);
  ASSERT_EQ(logic.currentPiece.x, initialX + 1);
}

TEST_F(LogicTest, Rotate) {
  logic.Rotate();
  ASSERT_EQ(logic.currentPiece.rotation, 1);
  logic.Rotate();
  ASSERT_EQ(logic.currentPiece.rotation, 2);
}

TEST_F(LogicTest, LineClear) {
  // Fill the bottom row to simulate a full line
  FillRow(BOARD_HEIGHT - 1);

  // Call CheckLines() directly to test its logic
  logic.CheckLines();

  // The bottom row should now be empty after clearing
  ASSERT_TRUE(IsRowEmpty(BOARD_HEIGHT - 1));
}

TEST_F(LogicTest, CollisionTest) {
  logic.currentPiece.x = 0;           // Move piece to the far left
  logic.Move(-1, 0);                  // Attempt to move further left
  ASSERT_EQ(logic.currentPiece.x, 0); // Should not move past the wall
}

// New test for the Next Piece Preview feature
TEST(LogicNextPieceTest, NextPieceSpawn) {
  // Create a fresh Logic instance to test its constructor and SpawnPiece
  // behavior
  Logic logic;

  // 1. Check that nextPiece is initialized and not NONE.
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.nextPiece.type),
            1); // Ensure it's a valid piece type (1-7)
  ASSERT_LE(static_cast<int>(logic.nextPiece.type), 7);

  // 2. Store the type of the initial nextPiece.
  PieceType initialNextPieceType = logic.nextPiece.type;

  // Also check that currentPiece is initialized and not NONE.
  ASSERT_NE(logic.currentPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.currentPiece.type), 1);
  ASSERT_LE(static_cast<int>(logic.currentPiece.type), 7);

  // To trigger SpawnPiece (which happens after LockPiece),
  // we need to move currentPiece to a position where it will lock.
  // Create a temporary piece to find the lock position without modifying
  // logic.currentPiece prematurely.
  Piece pieceToMove = logic.currentPiece;
  // Ensure all relevant properties are copied for the simulation
  pieceToMove.x = logic.currentPiece.x;
  pieceToMove.y = logic.currentPiece.y;
  pieceToMove.rotation = logic.currentPiece.rotation;

  // Move the piece down until it hits the bottom or another block
  while (logic.IsValidPosition(pieceToMove)) {
    pieceToMove.y++;
  }
  // Move it back up one step, so it's in a valid position but will lock on the
  // next downward movement or LockPiece call.
  pieceToMove.y--;

  // Set the logic's currentPiece to this calculated lock position.
  logic.currentPiece = pieceToMove;

  // Now, call LockPiece. This will lock the currentPiece and then call
  // SpawnPiece internally.
  logic.LockPiece();

  // 4. Assert that the new currentPiece's type is equal to the type of the OLD
  // nextPiece.
  ASSERT_EQ(logic.currentPiece.type, initialNextPieceType);

  // 5. Assert that nextPiece has changed (i.e., it's a new valid random piece).
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  ASSERT_GE(static_cast<int>(logic.nextPiece.type),
            1); // Ensure it's a valid piece type
  ASSERT_LE(static_cast<int>(logic.nextPiece.type), 7);

  // Assert that the new nextPiece is valid
  ASSERT_NE(logic.nextPiece.type, PieceType::NONE);
  // Note: It IS possible for nextPiece to be same type as currentPiece (random
  // 1/7 chance), so we don't assert inequality here.
}